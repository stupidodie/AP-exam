%%%-------------------------------------------------------------------
%%% @author Ken Friis Larsen <kflarsen@diku.dk>
%%% @copyright (C) 2017-2020, Ken Friis Larsen
%%% @doc
%%% This is a (partial) implementation of the (old-style) `eqc_statem'
%%% library from Quviq AB. It intended to have a subset of the API
%%% offered by `eqc_statem'. Thus, any documentation for `eqc_statem'
%%% should be usable as documentation for this library.
%%%
%%% === Not for redistribution ===
%%% This library is only for use on the course Advanced Programming,
%%% and should not be redistributed.
%%%
%%% === The callback functions ===
%%% The client module specifies an abstract state machine by defining
%%% the following functions:
%%% <ul>
%%% <li>`initial_state() ->' {@type symbolic_state()}
%%%   <p>Returns the state in which each test case starts (unless a
%%%   different initial state is supplied explicitly). This symbolic
%%%   state is evaluated to construct the initial dynamic state before
%%%   each test case is executed.</p></li>
%%% <li> `command(S :: '{@type symbolic_state()}`) ->' {@type eqc_gen:gen(call())}
%%%   <p>Generates an appropriate symbolic function call to appear
%%%   next in a test case, if the symbolic state is `S'. Test sequences
%%%   are generated by using `command(S)' repeatedly. However, generated
%%%   calls are only included in test sequences if their precondition
%%%   is also true.</p></li>
%%% <li>`precondition(S::'{@type symbolic_state()}`,
%%%                   Call::'{@type call()}`) -> boolean()'
%%%   <p>Returns `true' if the symbolic call `Call' can be performed
%%%   in the state `S'. Preconditions are used to decide whether or
%%%   not to include candidate commands in test cases, which is why
%%%   only the symbolic state information is available when
%%%   preconditions are checked.</p></li>
%%% <li>`postcondition(S::'{@type dynamic_state()}`,
%%%                    Call::'{@type call()}`,
%%%                    Res::term()) -> boolean()'
%%%   <p>Specifies the postcondition that should hold about the result `Res' of
%%%   performing `Call', given the dynamic state `S' of the abstract state
%%%   machine prior to command execution. This function is called during
%%%   runtime, this is why the state is dynamic.</p></li>
%%% <li>`next_state(S::'{@type symbolic_state()} `|' {@type dynamic_state()}`,
%%%                 Res::{@type var()} `|' term(),
%%%                 Call::'{@type call()}`) ->'
%%%        {@type symbolic_state()} `|' {@type dynamic_state()}
%%%   <p>Specifies the next state of the abstract state machine, given the
%%%   current state `S', the symbolic `Call' chosen and its result `Res'. This
%%%   function is called both at command generation and command execution time
%%%   in order to update the model state, therefore the state `S' and the
%%%   result `Res' can be either symbolic or dynamic.</p></li>
%%% </ul>
%%% @end
%%% Created : Oct 2017 by Ken Friis Larsen <kflarsen@diku.dk>
%%%-------------------------------------------------------------------
-module(apqc_statem).
-include_lib("eqc/include/eqc.hrl").


%%%===================================================================
%%% API
%%%===================================================================

-export([commands/1, commands/2]).
-export([run_commands/2, run_commands/3]).
-export([command_names/1, pretty_commands/4]).



%% -----------------------------------------------------------------------------
%% Type declarations
%% -----------------------------------------------------------------------------


-type call() :: {call, module(), atom(), [expr()]}.
-type command() :: {'set', var(), call()}
			     | {'init', symbolic_state()}.
-type dynamic_state() :: any().
-type exit() :: {'EXIT', term()}.

-type expr() :: term().

-type reason() :: ok
                | initialization
                | {precondition, boolean() | exit()}
                | {postcondition, boolean() | exit()}
                | {exception, exit()}.

-type symbolic_state() :: any().

-type var() :: {var, pos_integer()}.

-type history() :: [{dynamic_state(), term()}].

-type env() :: [{atom(), term()}].

%% -----------------------------------------------------------------------------
%% qpqc_statem behaviour callback functions
%% ----------------------------------------------------------------------------

-callback initial_state() -> symbolic_state().

-callback command(symbolic_state()) -> eqc_gen:gen(call()).

-callback precondition(symbolic_state() | dynamic_state(), call()) -> boolean().

-callback postcondition(dynamic_state(), call(), term()) -> boolean().

-callback next_state(symbolic_state() | dynamic_state(),
                     var()            | any(),
                     call()) -> symbolic_state() | dynamic_state().


-spec commands(module()) -> eqc_gen:gen([command()]).
commands(Module) ->
    ?LET(Initial, ?LAZY(Module:initial_state()),
         gen_commands(Module, Initial)).

-spec commands(module(), symbolic_state()) -> eqc_gen:gen([command()]).
commands(Module, Initial) ->
    gen_commands(Module, Initial).

-spec gen_commands(module(), symbolic_state()) -> eqc_gen:gen([command()]).
gen_commands(Module, Initial) ->
    Shrink = fun(Commands) ->
             ?LET(Cmds, Commands,
                  ?SHRINK(Cmds,
                          [?SUCHTHAT(SubCmds, sublist(Cmds),
                                     well_defined(Module, SubCmds, Initial, sets:new()))]))
             end,
    ?LET(Cmds, Shrink(?SIZED(Size, sized_commands(Size, Module, Initial, 1))),
         [{init,Initial}|Cmds]).


-spec sized_commands(non_neg_integer(), module(), symbolic_state(), pos_integer()) -> eqc_gen:gen([command()]).
sized_commands(0, _Module, _SymState, _NextVar) -> return([]);
sized_commands(Size, Module, SymState, NextVar) ->
    ?LAZY(
         ?LET(Cmd, ?SUCHTHAT(C, Module:command(SymState),
                             Module:precondition(SymState, C)),
              begin
                  Var = {var, NextVar},
                  NextState = Module:next_state(SymState, Var, Cmd),
                  Command = {set, Var, Cmd},
                  ?LET(Commands,
                       sized_commands(Size - 1, Module,
                                    NextState,
                                    NextVar + 1),
                       [ Command | Commands ])
              end)).


well_defined(_Mod, [], _State, _Defs) ->
    true;
well_defined(Mod, [{init, S} | Cmds], _State, Defs) ->
    well_defined(Mod, Cmds, S, Defs);
well_defined(Mod, [{set, Var, {call,_M,_F,A} = Call} | Cmds], State, Defs ) ->
    args_defined(A, Defs) andalso Mod:precondition(State, Call) andalso
        well_defined(Mod, Cmds, Mod:next_state(State, Var, Call),
                     sets:add_element(Var, Defs)).

args_defined(Args, Defs) ->
    lists:all(fun(X) -> sets:is_element(X, Defs) end, free_vars(Args)).


free_vars([X | Xs]) ->
    free_vars(X) ++ free_vars(Xs);
free_vars({var, Name}=Var) when is_integer(Name) ->
    [Var];
free_vars(Tuple) when is_tuple(Tuple) ->
    lists:concat(lists:map(fun free_vars/1, tuple_to_list(Tuple)));
free_vars(Map) when is_map(Map) ->
    lists:concat(lists:map(fun free_vars/1, maps:keys(Map) ++ maps:values(Map)));
free_vars(_Term) ->
    [].




-spec run_commands(Module::module(), Commands::[command()]) -> {history(), dynamic_state(), reason()}.
run_commands(Module, Commands) ->
     run_commands(Module, Commands, []).


-spec run_commands(Module::module(), Commands::[command()], Env::env()) -> {history(), dynamic_state(), reason()}.
run_commands(Module, Commands, Env) ->
    Initial = case Commands of
                 [ {init, S} | _ ] -> S;
                 _                 -> Module:initial_state()
             end,
    InitialDyn = eqc_symbolic:eval(Env, Initial),
    run_commands(Module, Commands, Env, [], InitialDyn).


-spec run_commands(Callback :: module(), Cmds :: [command()], Env :: env(),
                   history(), dynamic_state()) ->
                          {history(), dynamic_state(), reason()}.
run_commands(Callback, Cmds, Env, History, State) ->
    case Cmds of
        [] ->
            finish(History, State, ok);
        [{init, Initial} | Rest] ->
            InitialDyn = eqc_symbolic:eval(Env, Initial),
            run_commands(Callback, Rest, Env, History, InitialDyn);
        [{set, {var,V}, {call, M, F, A}} | Rest] ->
            Mod  = eqc_symbolic:eval(Env, M),
            Fun  = eqc_symbolic:eval(Env, F),
            Args = eqc_symbolic:eval(Env, A),
            Call = {call, Mod, Fun, Args},
            try Callback:precondition(State, Call) of
                true ->
                    try erlang:apply(Mod, Fun, Args) of
                        Res ->
                            NextEnv = [{V, Res} | Env],
                            NextHist = [{State, Res} | History],
                            try Callback:postcondition(State, Call, Res) of
                                true ->
                                    NextStateSym = Callback:next_state(State, Res,
                                                                       Call),
                                    NextState = eqc_symbolic:eval(NextEnv,
                                                                  NextStateSym),
                                    run_commands(Callback, Rest,
                                                 NextEnv, NextHist, NextState);
                                false ->
                                    finish(NextHist, State,
                                           {postcondition, {Mod, Fun}, false})
                            catch K:R ->
                                    finish(NextHist, State,
                                           {postcondition, {'EXIT', {K, R}}})
                            end
                    catch
                        Kind:Reason ->
                            finish(History, State,
                                   {exception, {'EXIT', {Kind, Reason}}})
                    end;
                false ->
                    finish(History, State, {precondition, false})
            catch
                Kind:Reason ->
                    finish(History, State, {precondition, {'EXIT', {Kind, Reason}}})
            end
    end.

finish(History, State, Reason) ->
     {lists:reverse(History), State, Reason}.

-spec command_names(Cmds::[command()]) -> [mfa()].
command_names(Cmds) ->
    [{Mod, Fun, length(Args)} || {set, _Var, {call, Mod, Fun, Args}} <- Cmds].


-spec pretty_commands(Mod::module(), Cmds::[command()], HSRes::{history(), dynamic_state(), reason()},
                      P:: eqc:property()) -> eqc:property().
pretty_commands(_Mod, Cmds, {Hist, _S, Reason}, P) ->
    ?WHENFAIL(case Reason of
                  ok -> print_commands_hist(Cmds, Hist);
                  _  -> print_commands_hist(Cmds, Hist++[Reason])
              end, P).


print_commands_hist([{init, S} | Cmds], H) ->
    eqc:format("~nInitial sym state: ~p~n", [S]),
    print_commands_hist(Cmds, H);
print_commands_hist(Cmds, H) ->
    eqc:format("~n",[]),
    [pretty_call(Var, Call,Res) ||
	{{set,Var, Call},{_,Res}} <- zip_short(Cmds, H)].

pretty_call({var, N}, Call, Res) ->
    eqc:format("V~B = ~s, % -> ~W~n",[N, eqc_symbolic:pretty_print(Call), Res, 8]).

zip_short([A|X], [B|Y]) -> [{A, B} | zip_short(X, Y)];
zip_short(_, [])        -> [];
zip_short([], _)        -> [].
